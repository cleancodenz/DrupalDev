<?php 
/**
 * @file
 * A node module that defines a node type: .
 */

/**
 * Implements hook_help.
 *
 * Displays help and module information.
 *
 * @param path
 *   Which path of the site we're using to display help
 * @param arg
 *   Array that holds the current path as returned from arg() function
 */

function cleancode_realestate_listing_help($path, $arg) {
	switch ($path) {
		case 'help/cleancode_realestate_listing':
			return "<p>" . t("The module to provide real estate listing.
			You can create new real estate listing using the <a href='!nodeadd'>real estate add</a>.",
			array('!nodeadd' => url('node/add/cleancode_realestate_listing'))) . "</p>";
	}
}


/**
 * Implements hook_install.
 *
 *This hook is called when the user enables the module for the first time
 *(or on subsequent enables after the module has been uninstalled).
 *So it's a good place to define our new node type.
 *
 * Add the body field.
 * Configure the body field. 
 *
 */
function cleancode_realestate_listing_install() {

	// During installation, the t() function is unavailable, so we use get_t()
	// to store the name of the translation function.
	$t = get_t();

	// We define the node type as an associative array.
	$cleancode_realestate_listing = array(
			'type' => 'cleancode_realestate_listing',
			'name' => $t('Real Estate Listing'),
			// 'base' tells Drupal the base string for hook functions.
			// This is often the module name; if base is set to 'mymodule', Drupal
			// would call mymodule_insert() or similar for node hooks.
	// In this case, we set base equal to 'node_content' so Drupal will handle
	// our node as if we had designed it in the UI.
	'base' => 'node_content',
	'description' => $t('The real estate listing entity.'),
	'title_label' => $t('Real Estate Listing'),
	'custom' => TRUE,
	);

	// Complete the node type definition by setting any defaults not explicitly
	// declared above.
	// http://api.drupal.org/api/function/node_type_set_defaults/7
	$content_type = node_type_set_defaults($cleancode_realestate_listing);

	//We add a body field and set the body label immediately.
	node_add_body_field($content_type, $t('Body Example Description'));


	// Save the content type
	node_type_save($content_type);

	// Load the instance definition for our content type's body
	// http://api.drupal.org/api/function/field_info_instance/7
	$body_instance = field_info_instance('node', 'body', 'cleancode_realestate_listing');

	//As an alternative for node_add_body_field($type, $label = 'Body')
	//the 'label'-key can be used to set the body label on the field instance
	//$body_instance['label'] = $t('Example Description');

	// Add our example_node_list view mode to the body instance display by
	// instructing the body to display as a summary
	$body_instance['display']['cleancode_realestate_listing_list'] = array(
			'label' => 'hidden',
			'type' => 'text_summary_or_trimmed',
	);

	// Save our changes to the body field instance.
	// http://api.drupal.org/api/function/field_update_instance/7
	field_update_instance($body_instance);

	// Create all the fields we are adding to our content type.
	// http://api.drupal.org/api/function/field_create_field/7
	foreach (_cleancode_realestate_listing_installed_fields() as $field) {
		field_create_field($field);
	}

	// Create all the instances for our fields.
	// http://api.drupal.org/api/function/field_create_instance/7
	foreach (_cleancode_realestate_listing_installed_instances() as $instance) {
		$instance['entity_type'] = 'node';
		$instance['bundle'] = $cleancode_realestate_listing['type'];
		field_create_instance($instance);
	}

}

/**
 * Implements hook_uninstall.
 *
 * This hook is called when the user not only has disabled the module, 
 * but also uninstalls it from the 'uninstall' tab in the module page.
 * So it's a perfect time to remove our fields and instances and new node type from the database.
 *
 */

function cleancode_realestate_listing_uninstall() {
	// Gather all the example content that might have been created while this
	// module was enabled.  Simple selects still use db_query().
	// http://api.drupal.org/api/function/db_query/7
	$sql = 'SELECT nid FROM {node} n WHERE n.type = :type';
	$result = db_query($sql, array(':type' => 'cleancode_realestate_listing'));
	$nids = array();
	foreach ($result as $row) {
		$nids[] = $row->nid;
	}

	// Delete all the nodes at once
	// http://api.drupal.org/api/function/node_delete_multiple/7
	node_delete_multiple($nids);

	// Loop over each of the fields defined by this module and delete
	// all instances of the field, their data, and the field itself.
	// http://api.drupal.org/api/function/field_delete_field/7
	foreach (array_keys(_cleancode_realestate_listing_installed_fields()) as $field) {
		field_delete_field($field);
	}

	// Loop over any remaining field instances attached to the node_example
	// content type (such as the body field) and delete them individually.
	// http://api.drupal.org/api/function/field_delete_field/7
	$instances = field_info_instances('node', 'cleancode_realestate_listing');
	foreach ($instances as $instance_name => $instance) {
		field_delete_instance($instance);
	}

	// Delete our content type
	// http://api.drupal.org/api/function/node_type_delete/7
	node_type_delete('cleancode_realestate_listing');

	// Purge all field infromation
	// http://api.drupal.org/api/function/field_purge_batch/7
	field_purge_batch(1000);
}

/**
 * Internal function.
 *Returns a structured array defining the fields created by this content type.
 *
 */

function _cleancode_realestate_listing_installed_fields() {
	
	$t = get_t();
	
	return array(
			'cleancode_realestate_listing_color' => array(
					'field_name' => 'cleancode_realestate_listing_color',
					'cardinality' => 3,
					'type' => 'text',
					'settings' => array(
							'max_length' => 60,
					),
			),
			'cleancode_realestate_listing_quantity' => array(
					'field_name' => 'cleancode_realestate_listing_quantity',
					'cardinality' => 1,
					'type' => 'text',
			),
			'cleancode_realestate_listing_image' => array(
					'field_name' => 'cleancode_realestate_listing_image',
					'type' => 'image',
					'cardinality' => 1,
			),
	);
}

/**
 * Internal function.
 *Returns a structured array defining the instances for this content type.
 *The instance lets Drupal know which widget to use to allow the user to enter data and how to react in different view modes.
 *We are going to display a page that uses a custom "node_example_list" view mode. 
 *We will set a cardinality of three allowing our content type to give the user three color fields.
 *
 */

function _cleancode_realestate_listing_installed_instances() {

	$t = get_t();
	return array(
			'cleancode_realestate_listing_color' => array(
					'field_name' => 'cleancode_realestate_listing_color',
					'label' => $t('The colors available for this object.'),
					'widget' => array(
							'type' => 'text_textfield',
					),
					'display' => array(
							'cleancode_realestate_listing_list' => array(
									'label' => 'hidden',
									'type' => 'cleancode_realestate_listing_colors',
							),
					),
			),
			'cleancode_realestate_listing_quantity' => array(
					'field_name' => 'cleancode_realestate_listing_quantity',
					'label' => $t('Quantity required'),
					'type' => 'text',
					'widget' => array(
							'type' => 'text_textfield',
					),
					'display' => array(
							'cleancode_realestate_listing_list' => array(
									'label' => 'hidden',
									'type' => 'hidden',
							),
					),
			),
			'cleancode_realestate_listing_image' => array(
					'field_name' => 'cleancode_realestate_listing_image',
					'label' => $t('Upload an image:'),
					'required' => FALSE,
					'widget' => array(
							'type' => 'image_image',
							'weight' => 2.10,
					),
					'display' => array(
							'cleancode_realestate_listing_list' => array(
									'label' => 'hidden',
									'type' => 'image_link_content__thumbnail',
							),
					),
			),
	);
}


/**
 * Implements hook_theme().
 * 
 * This lets us tell Drupal about our theme functions and their arguments
 *
 *
 */

function cleancode_realestate_listing_theme($existing, $type, $theme, $path) {
	return array(
			'cleancode_realestate_listing_color' => array(
					'variables' => array('color' => NULL),
			),
	);
}


/**
 * Implements hook_permission.
 *
 *Define the permissions that are used by this entity.
 *
 *
 */
function cleancode_realestate_listing_permission() {

	return array(
			'create cc real estate listing' =>
			array('title' => t('Create access to real estate listing contents')),
			'edit any cc real estate listing' =>
			array('title' => t('Edit access to any real estate listings')),
			'edit own cc real estate listings'=>
			array('title' => t('Edit access to their own real estate listing contents')),
			'delete any cc real estate listing' =>
			array('title' => t('Delete access to any real estate listings')),
			'delete own cc real estate listings'=>
			array('title' => t('Delete access to their own real estate listing contents')),
				
	);

}


/**
 * Implements hook_access.
 *
 *Access control of operation on CRUD.
 *
 * @param op
 *
 * @param node
 *
 * @param account
 *
 */
function cleancode_realestate_listing_access($op, $node, $account) {

	if ($op == 'create') {
		// Only users with permission to do so may create this node type.
		return user_access('create cc real estate listing', $account);
	}

	if ($op == 'update') {
		if ( user_access('edit any cc real estate listing', $account) ||
				(user_access('edit own cc real estate listings', $account) && ($account->uid == $node->uid))) {
			return TRUE;
		}
	}


	if ($op == 'delete') {
		if ( user_access('delete any cc real estate listing', $account) ||
				(user_access('delete own cc real estate listings', $account) && ($account->uid == $node->uid))) {
			return TRUE;
		}
	}


}


/**
 * Implements hook_form.
 *
 * Form collecting the information.
 *
 * @param form
 *
 * @param formstate
 *
 *
 */
function cleancode_realestate_listing_form($form, &$form_state) {

	$type = node_get_types('type', $form);

	// We need to define form elements for the node's title and body.
	$form['title'] = array(
			'#type' => 'textfield',
			'#title' => check_plain($type->title_label),
			'#required' => TRUE,
			'#default_value' => $form->title,
			'#weight' => -5
	);

	// We want the body and filter elements to be adjacent. We could try doing
	// this by setting their weights, but another module might add elements to the
	// form with the same weights and end up between ours. By putting them into a
	// sub-array together, we're able force them to be rendered together.
	$form['body_filter']['body'] = array(
			'#type' => 'textarea',
			'#title' => check_plain($type->body_label),
			'#default_value' => $form->body,
			'#required' => FALSE
	);

	$form['body_filter']['filter'] = filter_form($form->format);


	return system_settings_form($form);

}
